---
layout: post
title: Trabalhando com software livre
snip:  Pensando fora da caixa.
---

## Dicas importantes

Muitos de programadores desejam começar a construir um projeto de software livre mas não tem certeza de como as coisas funcionam. Vou deixar então aqui algumas dicas de ouro para que você não comece de maneira equivocada:

Por exemplo, é altamente recomendável que você não comece com o seu próprio projeto de software livre. Muita gente quer escrever software livre, então a primeira coisa que fazem é rabiscar algum código, colocar sob a GNU/GPL, e lançar a versão 0.0.1 alpha. De fato fazer isto é demasiadamente divertido e, possivelmente, educacional, no entanto isso pode ser também improdutivo. Eis o porquê:

É mais vantajoso e educativo estudar e aprender com código de outras pessoas pela adição de pequenas características aqui e ali, ou por correção de alguns bugs. A maioria dos projetos tem um bug tracker; por exemplo, no projeto Gnome temos bugs.gnome.org , no Debian e no Fedora Project temos o mesmo sistema , etc. Encontre um bug no tracker, e procure aprender por corrigi-lo. Ou adicionar um recurso que você está querendo. Obviamente, também é mais útil limpar o código existente do que lançar um projeto sozinho e que provavelmente em pouco tempo fique obsoleto ou pior, nem chegue a terminar.

Além disso, podemos tirar por alto que quase sempre, alguém já está trabalhando em tudo o que você quer escrever; é melhor terminar um projeto do que ter dois projetos inacabados. Lhe garanto que 95% dos projetos de software livre desaparecem no esquecimento antes de se tornar útil. Do ponto de vista de educacional, e também do ponto de vista da fama que você pode adquirir, inevitavelmente você precisará de pessoas para lhe ajudar a manter a coisa funcionando. Não desperdice tempo tentando reinventar a roda.

Vamos supor por exemplo, que você tenha alguma experiência hacking e há um app interessante que ninguém está trabalhando, neste caso, definitivamente comece a fazer algo. Se você começar um projeto, a coisa mais importante é planejar brevemente e escrever o código. Você tem que codificar o suficiente para fazer o app útil praticamente por si mesmo; isso pode levar meses ou anos de trabalho solitário, a menos que alguma alma caridosa decide ajudar com o seu app em vez de começar o seu próprio. Consegue ver como funciona?

Geralmente você tem que corrigir erros de forma rápida e, manter as coisas interessantes. Quando se trata de escrever um aplicativo livre, geralmente requer uma enorme quantidade de trabalho. Portanto, seja um self-starter. Muitas pessoas postam sua intenção de escrever aplicação X, ou anunciar a versão 0.0.1 alpha, e, em seguida, sequer começam o projeto. Ou seja, independente de quem fechar a ideia contigo, se propor a lhe ajudar, comece o projeto. No início, não haverá muita resposta até que você tenha usuários. E não haverá usuários até que você escreva código. Então você executando a sua própria determinação.

Use as listas de discussão. Se você tiver alguma dúvida, pergunte na lista ( pouquíssimas pessoas tem o hábito de usar a mailing list no Brasil ). Se você enviar perguntas na lista, a probabilidade de haver resposta e ajuda de desenvolvedores, é absurda. Além do que, muitos provavelmente estarão aprendendo a resolve o mesmo problema que você. As listas de discussão e documentação são criados pelos desenvolvedores para apoiar um grande número de usuários. Lembre-se que neste ramo, todo mundo é um voluntário, mas isto não quer dizer que não existirá uma consultoria paga ( um melhor acompanhamento ) e não tem nada de errado nisto.

Geralmente, ninguém estará no comando. Muitas vezes as pessoas esperam alguém para estar no comando de projetos de software livre; ou se espera obter uma atribuição, para que tudo ocorra bem mediante o prazo estipulado pela equipe. Na maioria dos casos, simplesmente não funciona dessa maneira embora, provavelmente, haverá muitas sugestões. O foco deve ser este : Mergulhe no projeto e faça acontecer.

Se você passar 3 meses escrevendo algum novo recurso interessante, e depois descobrir que o mantenedor odeia a idéia, e não terá patch, ou descobrir que seu patch não se aplica para a última versão de desenvolvimento, ou até descobrir que outra pessoa fez o mesmo trabalho, provavelmente você ficará puto. Se você está planejando trabalhar em algo, seja direto e avise ao mantenedor sobre o assunto. A maioria dos mantenedores são bem céticos com algumas propostas que surgem. É interessante você saber conversar e melhor, saber prototipar, projetar a sua ideia.

Seja sábio, saiba esperar o momento certo. A tentação de se juntar a uma lista de discussão e começar a comentar sobre tudo, geralmente é bem forte. Mas não se torne um programador back-seat. Ou seja, prefira contribuir se você tiver experiências relevantes, descobrir como reproduzir o bug, especialidades na área, saber a resposta para a pergunta etc.. Caso contrário, é sempre uma boa idéia se esconder um pouco em um fórum antes de você começar a postar, observar e aprender como as coisas funcionam antes de qualquer atitude que você venha a ter.

Entenda de direitos autorais, patentes, licenças, marcas, e assim por diante. Você tem que ser um pouco advogado para se envolver em software livre. Isto significa que você tem a responsabilidade de educar-se. Tradicionalmente, uma maneira de aprender é observar os exaustivos flamewars sobre o assunto no foróum gnu.misc.discuss. A maneira mais rápida de se informar, é lendo o [gnu.org](http://www.gnu.org). Evite publicar qualquer coisa sobre questões jurídicas, se você não compreende suficientemente ainda.

Saiba mais sobre a comunidade. É uma boa idéia manter-se atento em sites de notícias, como LinuxToday , LWN Slashdot, Phoronix e também sites relacionados aos projetos específicos que você está envolvido. Um bom livro sobre a história da comunidade é chamado Hackers , escrito por Steven Levy além do já mencionado site do gnu.



## 5. References and Additional Reading

<dl>
  <dt><a href="http://lucacardelli.name/Papers/TypeSystems.pdf">Type Systems</a></dt>
  <dd>Lucca Cardelli</dd>

  <dt><a href="http://www.haskell.org/definition/haskell98-report.pdf">Haskell 98 Language and Libraries: The Revised Report</a></dt>
  <dd>Simon Peyton Jones</dd>

  <dt><a href="http://bracha.org/newspeak.pdf">The Newspeak Programming Platform</a></dt>
  <dd>Gilad Bracha, Peter Ahe, Vassili Bykov, Yaron Kashai, and Eliot Miranda</dd>

  <dt><a href="http://bracha.org/newspeak-modules.pdf">Modules as Objects in Newspeak</a></dt>
  <dd>Gilad Bracha, Peter von der Ahé, Vassili Bykov, Yaron Kashai, William Maddox, and Eliot Miranda</dd>

  <dt><a
  href="http://www.schemeworkshop.org/2011/papers/Scholliers2011.pdf">Computational Contracts</a></dt>
  <dd>Christophe Scholliers, Éric Tanter, and Wolfgang de Meuter</dd>

  <dt><a href="http://dl.acm.org/citation.cfm?id=2162141">Epigram: Practical
  Programming with Dependent Types</a></dt>
  <dd>Conor McBride</dd>

  <dt><a href="http://www.mpi-sws.org/~rossberg/f-ing/">F-Ing Modules</a></dt>
  <dd>Andreas Rossberg, Claudio Russo, and Derek Dreyer</dd>

  <dt><a
  href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.39.6996">Types, Abstraction, and Parametric Polymorphism, Part 2</a></dt>
  <dd>QingMing Ma, and John C. Reynolds</dd>

  <dt><a
  href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.67.5276">A theory of type polymorphism in programming</a></dt>
  <dd>Robin Milner</dd>

  <dt><a
  href="http://web.cs.wpi.edu/~cs4536/c12/milner-damas_principal_types.pdf">Principal type-schemes for functional programs</a></dt>
  <dd>Luis Damas, and Robin Milner</dd>

  <dt><a
  href="http://haskell.cs.yale.edu/wp-content/uploads/2011/01/DSEL-Little.pdf">Domain Specific Languages</a></dt>
  <dd>Paul Hudak</dd>

  <dt><a
  href="http://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf">Why Functional Programming Matters</a></dt>
  <dd>John Hughes</dd>

  <dt><a
  href="http://www.infoq.com/presentations/functional-pros-cons">Deconstructing Functional Programming</a></dt>
  <dd>Gilad Bracha</dd>

  <dt><a
  href="http://www.infoq.com/presentations/past-present-future-programming">Onward! -- Does Thought Crime Pay?</a></dt>
  <dd>Gilad Bracha</dd>
</dl>
