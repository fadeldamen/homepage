---
layout: post
title: Design e Arquitetura ext4
snip:  Sistema de arquivos
---

Este artigo apresenta a concepção de implementação de um sistema de arquivos compatível com Unix, o ext4, que usa duas partições de disco para armazenar seus dados. Uma partição é usada exclusivamente para informações relacionadas ao diretório, e a outra para os arquivos ordinários. O sistema de arquivos é desenvolvido como uma modificação do sistema de arquivos ext2 onipresente. O objetivo é beneficiar o:

* O paralelismo no acesso às duas partições se forem armazenados em discos com controladores separados.

* O layout simplificado e melhorado que favorece padrões de acesso específicos para cada tipo de arquivo.

O sistema de arquivos ext4 é o resultado de uma tecnologia de sistema de arquivos de longa evolução que começa com o sistema de arquivos Unix concebido na década de setenta por Ken Thomson. Muitas idéias ainda são básicas (como o inodes); é interessante fazer uma analogia cronológica da evolução dos sistemas de arquivos Unix, que lança alguma luz sobre as escolhas que deram origem ao projeto do ext4.

---

Tabela de conteúdo
----
* **[UFS - Unix File System](#unix-file-system)**
* **[O sistema de arquivos Linux Ext2](#o-sistema-de-arquivos-linux-ext2)**





## Unix File System

O protótipo do sistema de arquivos continua a ser o sistema de arquivos Unix original, projetado por Ken Thomson. A sua modularidade, limpeza e simplicidade são compensados apenas pela leveza e baixa eficiência. De uma forma ou de outra, os novos sistemas são apenas "patches" do projeto original, e eles tentam compactar algumas linhas de desempenho, sacrificando a elegância do design. Basicamente funciona da seguinte forma: "se ele funciona rápido, não importa se é feio." O modelo de sistema de arquivo do Unix é muito simples: um array de bytes simples com um tamanho muito grande. A figura a baixo representa a colocação dos procedimentos do sistema de arquivos do kernel entre outros serviços do kernel.

<p align="center">
<img src ="https://raw.githubusercontent.com/lobocode/pesquisas/master/Sistema_de_arquivos/ga1.png" />
</p>

---

***File System Placement no sistema operacional***

O driver (e o cache) oferecem ao disco uma enorme variedade de blocos. O sistema de arquivos lê e escreve em tais blocos em uma única operação. Cada partição de disco tem que conter um sistema de arquivos independente. O sistema de ficheiro utiliza os blocos de partição do seguinte modo:

<p align="center">
<img src ="https://raw.githubusercontent.com/lobocode/pesquisas/master/Sistema_de_arquivos/ga2.png" />
</p>

---

***Utilizando a partição pelo sistema de arquivos***

Um superbloco contém uma descrição dos parâmetros globais do sistema de arquivos. Como por exemplo: tamanho da partição, montar a partição no tempo, número de inodes, blocos livres; inodes livres, tipo de sistema de arquivos. A seguir, um número de blocos é atribuída para armazenar descrições de arquivo individuais. Cada arquivo é descrito por um inode ou informação. O número de inodes é alocado estaticamente, no momento da criação do sistema de arquivos.

Todos os atributos relevantes são mantidos nos inodes, incluindo uma representação de uma lista de blocos usados pelo arquivo, (veja a imagem a seguir). Os blocos indiretos precisam estar presentes apenas se o tamanho do arquivo for grande o suficiente (ou seja, o ponteiro pode ser NULL "nulo"). 

<p align="center">
<img src ="https://raw.githubusercontent.com/lobocode/pesquisas/master/Sistema_de_arquivos/ga3.png" />
</p>

---

***Representação de lista de bloqueio em Inodes***

Os diretórios são, na verdade, em todos os aspectos, arquivos comuns (ou seja, blocos de inodes, e de dados que crescem da mesma forma), o sistema operacional se preocupa com o conteúdo do diretório. A estrutura de diretórios costuma ser bastante simples com um conjunto de links. Basicamente, um link é uma estrutura que associa um nome (string) com um número de inode. A Figura a seguir mostra a estrutura de diretórios. Cada arquivo tem que ter pelo menos um link em um diretório. O mesmo para diretórios também, exceto para o diretório root.

Todos os arquivos podem ser identificados pelo seu caminho, que é lista de links que devem ser percorridos para alcançar o arquivo (ou começando no diretório root, ou no diretório corrente). Um arquivo pode ter links em muitos diretórios; um diretório tem que ter um único link para si mesmo (exceto "." e ".."), a partir de seu diretório pai.

<p align="center">
<img src ="https://raw.githubusercontent.com/lobocode/pesquisas/master/Sistema_de_arquivos/ga4.png" />
</p>

---

***Diretório e estrutura do link***

O programa ```mkfs``` transforma uma partição "raw" em um sistema de arquivos com a criação do superbloco, inicializando inodes e prendendo todos os blocos de dados em uma lista enorme de blocos disponíveis para um crescimento futuro. Os blocos livres são praticamente agrupados em um grande arquivo fictício, a partir do qual eles são recuperados sob demanda (quando outros arquivos ou diretórios crescem), e ao qual regressam na remoção de arquivos ou truncamento.

Observemos que todas as operações realizadas em arquivos tem que trazer os dados relevantes (por exemplo, inodes) INCORE (na RAM). A representação no interior do núcleo das estruturas de dados é mais complexa do que a estrutura no disco, porque muita informação é implícita sobre o disco em falta no interior do núcleo (por exemplo, o número de inode, o dispositivo, o tipo de sistema de arquivos).

---

## O sistema de arquivos Linux Ext2

O sistema de arquivos ext2 inspira-se fortemente sobre o legado dos sistemas FFS e VFS. Ele tem suas próprias características, no entanto:

Tem fragmentos de blocos, o espaço é menos problemático com tamanhos de discos atuais; e tente a não sofrer sobrecarga. Além disto, contém outros fatores importantes como:

* Usa grupos (cilindro), com bitmaps para inode livre e rastreamento bloco livre;

<p align="center">
<img src ="https://raw.githubusercontent.com/lobocode/pesquisas/master/Sistema_de_arquivos/ga5.png" />
</p>

* Utiliza técnicas de pré-alocação para alcançar blocos de arquivos; cada arquivo crescente tenta reservar um número de blocos consecutivos, que são liberados se o crescimento não é seqüencial;

* Todos os bitmaps são reduzidos a uma quadra de tamanho, por razões de eficiência de pesquisa;

* Os arquivos são imutáveis, apenas anexa arquivos impostos pelo kernel; o ioctl() lida com seus atributos;

* As entradas do diretório tem tamanho variável; o diretório manipulation só é permitido através de chamadas de sistema especiais (por exemplo, readdir(), e não o read());

* Bits de desmontar limpa no superbloco permitir ignorar as verificações de consistência caros em tempo de boot;

* Rápidos links simbólicos (informações armazenadas na parte reservada para inode ponteiros bloco se ele se encaixa, e não alocar um bloco);

* Alguns recursos extras estão previstos, mas ainda não fora implementados, como a compressão transparente, File Undelete.

<p align="center">
<img src ="https://raw.githubusercontent.com/lobocode/pesquisas/master/Sistema_de_arquivos/ga6.png" />
</p>

---

***Estrutura do Grupo em ext2***

O poder do Virtual File System (VFS) aparente em Linux suporta até 10 diferentes sistemas, que vão desde a NFS a DOS e FAT etc... Existem três principais estruturas de dados na camada de Linux VFS, que apontam para o arquivo de sistema em partes dependentes e independentes. Estes são:

* O superbloco de cada sistema montado;
* Cada inodes \carregado "objeto (arquivos, diretório, tubulação, etc.)";
* As estruturas de arquivos, que descrevem arquivos abertos.

Cada versão no interior do kernel tem uma estrutura com ponteiros para os manipuladores. A Figura a seguir ilustra este fato para os inodes. 

<p align="center">
<img src ="https://raw.githubusercontent.com/lobocode/pesquisas/master/Sistema_de_arquivos/ga7.png" />
</p>

Aqui é uma estrutura típica do código do kernel, na rotina, uma dependencia do sistema de arquivo de ext2 que carrega um inode:

{% highlight C %} if (REGULAR(inode->mode))
inode->operations = &ext2_file_inode_operations;
	else if (DIRECTORY(inode->mode))
inode->operations = &ext2_dir_inode_operations;
	else if (SYMLINK(inode->mode))
inode->operations = &ext2_symlink_inode_operations;
else ... 
{% endhighlight %}
<br/>
O VFS vai chamar as operações do inode indiretamente (por exemplo inode-> Operações-> link()), sem ter que saber alguma coisa sobre a implementação.

---

### O sistema de arquivos ext4

O sistema de arquivos ext4 é, basicamente, um refinamento do ext2, que usa duas partições simultaneamente, idealmente localizado em discos separados. Ambas as partições contém informações como: inodes, blocos diretos e indiretos, superblocks e informações de bitmap. A única diferença entre as duas partições é que todos os diretórios irá se acomodar em um deles (ambos os blocos e inodes) e arquivos comuns no outro.

Agora todos os outros tipos de arquivos (links simbólicos, pipes nomeados, arquivos especiais) são mantidos na mesma partição dos arquivos regulares, embora o seu lugar certo, obviamente, é partição dos diretórios, porque o seu padrão de uso é supostamente semelhante aos próprios diretórios. Essa alteração não deve ser dificil. Este layout permite que as operações em arquivos e diretórios decorrerem em paralelo. Os pedidos de leitura/gravação de um bloco de diretório e um bloqueio de arquivo podem ser processados simultaneamente, reduzindo a latência percebida pelo usuário.

Observemos que os pedidos pendentes simultâneos de diretório e manipulação de arquivos surgem mesmo no contexto de entrada e saída I/O de um único processo de usuário, por causa do write-behind e read-ahead que são ações do cache; isso significa que eles não são uma circunstância exótica, e estamos realmente tentando resolver um problema real.

***Basicamente duas coisas têm que ser mudadas no ext2 para obter ext4:***

* A montagem e desmontagem de operações tem de operar em duas partições de uma só vez, e cruzar a validade das estruturas de dados;

* Todas as operações que lidam com carga/poupança de blocos tem que ser personalizado, para escolher uma ou outra partição, de acordo com o destino final do bloco manipulado.

Basicamente o ext4 tenta fazer uso de um tipo modificado da técnica RAID-0. A técnica RAID-0 transforma duas partições (discos) em uma única partição\virtual, quer pela concatenação de seus blocos, ou pelo entrelaçamento deles (de blocos ou seja, pares tomados de uma partição física e ímpar do outro). O RAID-0 não tem conhecimento sobre a estrutura do sistema de arquivos, e atinge o striping, isto é, "o nível do driver de dispositivo (note-se, de passagem, que o GNU/Linux possui um sistema de RAID-0, o driver md, que no entanto não tem conexão com o nosso projeto)".

Nosso sistema de arquivos tenta tirar vantagem do conhecimento do conteúdo do bloco, e divide os dados em dois discos em um "nível\superior."

---

Características gerais
----------------------

***Compatibilidade***

* Qualquer sistema de arquivos ext3 existente pode ser migrado para o ext4 com um procedimento fácil, que consiste na execução de um par de comandos em modo de somente leitura. Isso significa que você pode melhorar o desempenho, limites de armazenamento e recursos de seu sistema de arquivos atuais sem reformatar e/ou reinstalar o sistema operacional e ambiente de software. Se você precisar as vantagens do ext4 em um sistema de produção, você pode atualizar o sistema de arquivos.

* O procedimento é seguro e não coloca em risco os seus dados (obviamente, não é recomendado fazer isto em procedimentos onde há sistemas críticos como os de backup). O ext4 vai usar as novas estruturas de dados somente em novos dados, as velhas estruturas permanecerão intocadas e será possível ler/modificar quando necessário. Isto significa, naturalmente, que uma vez que você converte seu sistema de arquivos ext4, você não será capaz de voltar para ext3 novamente (embora haja uma possibilidade de montar um sistema de arquivos ext3 com ext4 sem usar o novo formato de disco e você será capaz de montar o ext3 novamente, mas perderá muitas das vantagens do ext4).

---

***Sistema de arquivos / tamanhos de arquivo maiores***

* Atualmente, ext3 suporta 16 TB como tamanho máximo do sistema de arquivos, e 2 TB de tamanho máximo pra arquivos. O ext4 acrescenta um bloco de endereçamento de 48 bits, por isso vai terá um EB proporcional ao sistema de arquivos e 16 TB de tamanho máximo para arquivos. 1 EB = 1.048.576 TB (1 EB = 1024 PB, PB 1 TB = 1024, 1 TB = 1024 GB). Por que 48 bits e não de 64 bits? Existem algumas limitações que precisam ser corrigidas antes de fazer que o ext4 seja totalmente compatível com 64 bits.

* A estrutura de dados do ext4 foi concebida tendo isso em mente, para uma futura atualização a equipe que desenvolve o ext4 irá implementar o suporte a 64 bits completo em algum ponto. 1 EB é suficiente até que isso aconteça.

---

***Escalabilidade Sub diretório***

* Agora o número máximo possível de sub-diretórios contidos em um único diretório em ext3 é 32000. ext4 quebra desse limite e permite um número ilimitado de sub-diretórios.

---

***Extensões***

* Os sistemas de arquivos do Unix tradicionalmente do qual deriva o ext3, usa um esquema de mapeamento de bloco indireto para manter o controle de cada bloco usado nos blocos correspondentes aos dados de um arquivo. Isto é ineficiente para arquivos grandes, especialmente em arquivos grandes que apagam e truncam operações, porque o mapeamento mantém uma entrada para cada bloco único, e os arquivos grandes acabam tendo excessivos blocos -> enormes mapeamentos, lentidão ao manusear. Sistemas de arquivos modernos usam uma abordagem diferente chamada de "extensões".

* Uma extensão é basicamente um grupo de blocos físicos contíguos. Por exemplo, um arquivo de 100 MB pode ser alocado em uma única extensão desse tamanho, em vez de precisar criar o mapeamento indireto para 25.600 blocos (4 KB por bloco). Arquivos enormes estão divididos em várias extensões. Extensões melhoraim o desempenho e também ajudam a reduzir a fragmentação, uma vez que uma medida alavancam os layouts contínuos no disco.

---

***Alocação multiblocos***

* Quando a formatação ext3 precisa gravar novos dados no disco, há um alocador de blocos que decide o bloqueio livre que será usado para gravar os dados. Mas o bloco alocador do ext3 aloca um bloco de (4KB) de cada vez. Isso significa que se o sistema precisa gravar os dados em MB, ele vai precisar ligar o alocador de blocos 25.600 vezes ( para apenas100 MB , por exemplo!).

* Isto é ineficiente, ele não permite que o alocador de bloco melhore a política de alocação porque não sabe o total de dados que está sendo alocado.O ext4 usa um "alocador multiblock" (mballoc) que aloca muitos blocos em uma única chamada, em vez de um único bloco por chamada, evitando sobrecarga. Isso melhora o desempenho, e é particularmente útil com a alocação atrasada e extensões. Este recurso não afeta o formato do disco. 

---

***Alocação atrasada***

* Alocação atrasada ou (Delayed allocation), é uma característica de desempenho encontrada em alguns sistemas de arquivos modernos, como XFS, ZFS, btrfs ou Reiser 4, e consiste em atrasar a alocação de blocos, tanto quanto possível, ao contrário do que tradicionalmente o sistemas de arquivos (como o ext3, reiser3, etc) fazem, que é basicamente alocar os blocos o mais rápido possível. Apesar de parecer ilógico haver alocação atrasada, a abordagem de alocação instantânea, esta abordagem tem desvantagens.

>  Por exemplo, quando um processo está escrevendo continuamente para um arquivo que tende a crescer gradativamente, o comportamento deste tipo de processo "instantaneo" é de gerar problema de alocação desconhecida por não ter uma estimativa do quanto o arquivo tenderá a crescer. Alocação atrasada, por outro lado, não aloca os blocos imediatamente quando o processo de gravação está em curso, em vez disso, atrasa a alocação dos blocos enquanto o arquivo é mantido em cache, até que ele é realmente seja escrito para o disco. Isto dá ao alocador de blocos a oportunidade de otimizar a alocação em situações em que o sistema antigo não podia.

---

***Fsck rápido***

* Fsck costumeiramente é uma operação muito lenta, especialmente o primeiro passo que consiste em verificar todos os inodes no sistema de arquivos. No ext4, no final da tabela inode de cada grupo é armazenado uma lista de inodes não utilizados (com uma soma de verificação, por segurança), assim o fsck não irá verificar estes inodes. O resultado é que o tempo total de fsck melhora de 2 a 20 vezes em termos de desempenho, dependendo do número de inodes usados [Kerneltrap.org](http://kerneltrap.org/Linux/Improving_fsck_Speeds_in_ext4).

* Deve ser notado que é o fsck, e não o ext4, que vai construir a lista de inodes não utilizados. Isso significa que você deve executar fsck para obter a lista de inodes não utilizados, e somente a próxima verificação do fsck será mais rápido (você precisa passar um fsck, a fim de converter um sistema de arquivos ext3 para ext4 de qualquer maneira). Há também um recurso que participa nesta melhora de performance do fsck - "os grupos de blocos flexíveis" - que também aceleram as operações do sistema de arquivos.

---

***Jornal checksumming***

* O Journal é a parte mais utilizada do disco, fazendo com que os blocos que formem parte dela estejam mais propensos a falhas de hardware. E se o usuário numa tentativa de manusear o sistema para recupera-lo através de um journal acabar por corrompe-lo, pode levar a um crash massivo. São nos checksums do ext4 que poderemos saber se os blocos do journal estão falhando ou corrompidos. Além disso, o journal checksumming tem um bônus: ele permite converter a confirmação de duas fases sistema de journaling do ext3 para uma única fase em ext4, acelerando a operação do sistema de arquivos até 20% em alguns casos - por isso a confiabilidade e desempenho são melhorados ao mesmo tempo. 

---

***Modo "Sem registro no Journaling"***

* O journaling garante a integridade do sistema de arquivos, mantendo um registro das alterações do disco em andamento. No entanto, sabe-se que haverá uma pequena sobrecarga. No ext4 o recurso de registro no journaling pode ser desabilitado, o que proporciona uma pequena melhoria de desempenho .

***A desfragmentação online***

* Enquanto o delayed allocation ***(locação atrasada)***, extensões e multiblock ajuda alocação de reduzir a fragmentação, n o entanto, isto não quer dizer que o sistemas de arquivos não irá fragmentar. Por exemplo: Você escreve três arquivos em um diretório continuamente no disco. Algum dia você precisará atualizar o arquivo, mas o arquivo atualizado tem crescido um pouco além da conta, de modo que não há espaço suficiente para ele. Para resolver este problema, ext4 vai apoiar fragmentação online, e há uma ferramenta e4defrag que pode desfragmentar arquivos individuais ou todo o sistema de arquivos.

---

***Inodes maiores:***

* O ext3 suporta tamanhos de inodes configuráveis (via o parâmetro mkfs -I), mas o tamanho do inode padrão é de 128 bytes.O ext4 suportará o padrão de 256 bytes. Isso é necessário para acomodar alguns campos extras (como timestamps nanossegundos ou inode de versão), e o espaço restante do inode será usado para armazenar e estender atributos que são pequenos o suficiente para caber nesse espaço. 

* Reservar Inodes consiste em reservar vários inodes quando um diretório é criado, esperando que eles sejam usados no futuro. Isso melhora o desempenho, porque quando novos arquivos forem criados no diretório, terá a capacidade de usar os inodes reservados. Criação de arquivo e eliminação é, portanto, mais eficiente.Timestamps nanossegundos significa que os campos de inode como "tempo modificado" seja capaz de usar a resolução nanossegundo em vez do segundo resolução de ext3.

---

Referências:
------------

* A Dual-Disk File System: ext4 - Mihai Budiu
* A High Performance Multi-Structured FIle System Design; Keith Muller and Joseph Pasquale -- Procedings of the Thirteen ACM Symposium on Operating System Principles
* Linux File System; Rémy Card, "Theodore Ts'o", Stephen Tweedie -- Slides
* File Management in the Linux Kernel; Rémy Card -- Slides
* Optimizations in File Systems; Stephen Tweedie -- Slides
* Linux Kernel Source Code and Linux Disk Utilities; Rémi Card, "Theodore Ts'o", Linus Torvalds -- Linux kernel 2.0.18

